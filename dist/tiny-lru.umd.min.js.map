{"version":3,"file":"tiny-lru.umd.min.js","sources":["../src/lru.js"],"sourcesContent":["/**\n * A high-performance Least Recently Used (LRU) cache implementation with optional TTL support.\n * Items are automatically evicted when the cache reaches its maximum size,\n * removing the least recently used items first. All core operations (get, set, delete) are O(1).\n *\n * @class LRU\n * @example\n * // Create a cache with max 100 items\n * const cache = new LRU(100);\n * cache.set('key1', 'value1');\n * console.log(cache.get('key1')); // 'value1'\n *\n * @example\n * // Create a cache with TTL\n * const cache = new LRU(100, 5000); // 5 second TTL\n * cache.set('key1', 'value1');\n * // After 5 seconds, key1 will be expired\n */\nexport class LRU {\n\t/**\n\t * Creates a new LRU cache instance.\n\t * Note: Constructor does not validate parameters. Use lru() factory function for parameter validation.\n\t *\n\t * @constructor\n\t * @param {number} [max=0] - Maximum number of items to store. 0 means unlimited.\n\t * @param {number} [ttl=0] - Time to live in milliseconds. 0 means no expiration.\n\t * @param {boolean} [resetTtl=false] - Whether to reset TTL when accessing existing items via get().\n\t * @example\n\t * const cache = new LRU(1000, 60000, true); // 1000 items, 1 minute TTL, reset on access\n\t * @see {@link lru} For parameter validation\n\t * @since 1.0.0\n\t */\n\tconstructor (max = 0, ttl = 0, resetTtl = false) {\n\t\tthis.first = null;\n\t\tthis.items = Object.create(null);\n\t\tthis.last = null;\n\t\tthis.max = max;\n\t\tthis.resetTtl = resetTtl;\n\t\tthis.size = 0;\n\t\tthis.ttl = ttl;\n\t}\n\n\t/**\n\t * Removes all items from the cache.\n\t *\n\t * @method clear\n\t * @memberof LRU\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.clear();\n\t * console.log(cache.size); // 0\n\t * @since 1.0.0\n\t */\n\tclear () {\n\t\tthis.first = null;\n\t\tthis.items = Object.create(null);\n\t\tthis.last = null;\n\t\tthis.size = 0;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes an item from the cache by key.\n\t *\n\t * @method delete\n\t * @memberof LRU\n\t * @param {string} key - The key of the item to delete.\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.set('key1', 'value1');\n\t * cache.delete('key1');\n\t * console.log(cache.has('key1')); // false\n\t * @see {@link LRU#has}\n\t * @see {@link LRU#clear}\n\t * @since 1.0.0\n\t */\n\tdelete (key) {\n\t\tif (this.has(key)) {\n\t\t\tconst item = this.items[key];\n\n\t\t\tdelete this.items[key];\n\t\t\tthis.size--;\n\n\t\t\tif (item.prev !== null) {\n\t\t\t\titem.prev.next = item.next;\n\t\t\t}\n\n\t\t\tif (item.next !== null) {\n\t\t\t\titem.next.prev = item.prev;\n\t\t\t}\n\n\t\t\tif (this.first === item) {\n\t\t\t\tthis.first = item.next;\n\t\t\t}\n\n\t\t\tif (this.last === item) {\n\t\t\t\tthis.last = item.prev;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an array of [key, value] pairs for the specified keys.\n\t * Order follows LRU order (least to most recently used).\n\t *\n\t * @method entries\n\t * @memberof LRU\n\t * @param {string[]} [keys=this.keys()] - Array of keys to get entries for. Defaults to all keys.\n\t * @returns {Array<Array<*>>} Array of [key, value] pairs in LRU order.\n\t * @example\n\t * cache.set('a', 1).set('b', 2);\n\t * console.log(cache.entries()); // [['a', 1], ['b', 2]]\n\t * console.log(cache.entries(['a'])); // [['a', 1]]\n\t * @see {@link LRU#keys}\n\t * @see {@link LRU#values}\n\t * @since 11.1.0\n\t */\n\tentries (keys = this.keys()) {\n\t\tconst result = new Array(keys.length);\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst key = keys[i];\n\t\t\tresult[i] = [key, this.get(key)];\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Removes the least recently used item from the cache.\n\t *\n\t * @method evict\n\t * @memberof LRU\n\t * @param {boolean} [bypass=false] - Whether to force eviction even when cache is empty.\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.set('old', 'value').set('new', 'value');\n\t * cache.evict(); // Removes 'old' item\n\t * @see {@link LRU#setWithEvicted}\n\t * @since 1.0.0\n\t */\n\tevict (bypass = false) {\n\t\tif (bypass || this.size > 0) {\n\t\t\tconst item = this.first;\n\n\t\t\tdelete this.items[item.key];\n\n\t\t\tif (--this.size === 0) {\n\t\t\t\tthis.first = null;\n\t\t\t\tthis.last = null;\n\t\t\t} else {\n\t\t\t\tthis.first = item.next;\n\t\t\t\tthis.first.prev = null;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the expiration timestamp for a given key.\n\t *\n\t * @method expiresAt\n\t * @memberof LRU\n\t * @param {string} key - The key to check expiration for.\n\t * @returns {number|undefined} The expiration timestamp in milliseconds, or undefined if key doesn't exist.\n\t * @example\n\t * const cache = new LRU(100, 5000); // 5 second TTL\n\t * cache.set('key1', 'value1');\n\t * console.log(cache.expiresAt('key1')); // timestamp 5 seconds from now\n\t * @see {@link LRU#get}\n\t * @see {@link LRU#has}\n\t * @since 1.0.0\n\t */\n\texpiresAt (key) {\n\t\tlet result;\n\n\t\tif (this.has(key)) {\n\t\t\tresult = this.items[key].expiry;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Retrieves a value from the cache by key. Updates the item's position to most recently used.\n\t *\n\t * @method get\n\t * @memberof LRU\n\t * @param {string} key - The key to retrieve.\n\t * @returns {*} The value associated with the key, or undefined if not found or expired.\n\t * @example\n\t * cache.set('key1', 'value1');\n\t * console.log(cache.get('key1')); // 'value1'\n\t * console.log(cache.get('nonexistent')); // undefined\n\t * @see {@link LRU#set}\n\t * @see {@link LRU#has}\n\t * @since 1.0.0\n\t */\n\tget (key) {\n\t\tconst item = this.items[key];\n\n\t\tif (item !== undefined) {\n\t\t\t// Check TTL only if enabled to avoid unnecessary Date.now() calls\n\t\t\tif (this.ttl > 0) {\n\t\t\t\tif (item.expiry <= Date.now()) {\n\t\t\t\t\tthis.delete(key);\n\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fast LRU update without full set() overhead\n\t\t\tthis.moveToEnd(item);\n\n\t\t\treturn item.value;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Checks if a key exists in the cache.\n\t *\n\t * @method has\n\t * @memberof LRU\n\t * @param {string} key - The key to check for.\n\t * @returns {boolean} True if the key exists, false otherwise.\n\t * @example\n\t * cache.set('key1', 'value1');\n\t * console.log(cache.has('key1')); // true\n\t * console.log(cache.has('nonexistent')); // false\n\t * @see {@link LRU#get}\n\t * @see {@link LRU#delete}\n\t * @since 9.0.0\n\t */\n\thas (key) {\n\t\treturn key in this.items;\n\t}\n\n\t/**\n\t * Efficiently moves an item to the end of the LRU list (most recently used position).\n\t * This is an internal optimization method that avoids the overhead of the full set() operation\n\t * when only LRU position needs to be updated.\n\t *\n\t * @method moveToEnd\n\t * @memberof LRU\n\t * @param {Object} item - The cache item with prev/next pointers to reposition.\n\t * @private\n\t * @since 11.3.5\n\t */\n\tmoveToEnd (item) {\n\t\t// If already at the end, nothing to do\n\t\tif (this.last === item) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remove item from current position in the list\n\t\tif (item.prev !== null) {\n\t\t\titem.prev.next = item.next;\n\t\t}\n\n\t\tif (item.next !== null) {\n\t\t\titem.next.prev = item.prev;\n\t\t}\n\n\t\t// Update first pointer if this was the first item\n\t\tif (this.first === item) {\n\t\t\tthis.first = item.next;\n\t\t}\n\n\t\t// Add item to the end\n\t\titem.prev = this.last;\n\t\titem.next = null;\n\n\t\tif (this.last !== null) {\n\t\t\tthis.last.next = item;\n\t\t}\n\n\t\tthis.last = item;\n\n\t\t// Handle edge case: if this was the only item, it's also first\n\t\tif (this.first === null) {\n\t\t\tthis.first = item;\n\t\t}\n\t}\n\n\t/**\n\t * Returns an array of all keys in the cache, ordered from least to most recently used.\n\t *\n\t * @method keys\n\t * @memberof LRU\n\t * @returns {string[]} Array of keys in LRU order.\n\t * @example\n\t * cache.set('a', 1).set('b', 2);\n\t * cache.get('a'); // Move 'a' to most recent\n\t * console.log(cache.keys()); // ['b', 'a']\n\t * @see {@link LRU#values}\n\t * @see {@link LRU#entries}\n\t * @since 9.0.0\n\t */\n\tkeys () {\n\t\tconst result = new Array(this.size);\n\t\tlet x = this.first;\n\t\tlet i = 0;\n\n\t\twhile (x !== null) {\n\t\t\tresult[i++] = x.key;\n\t\t\tx = x.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Sets a value in the cache and returns any evicted item.\n\t *\n\t * @method setWithEvicted\n\t * @memberof LRU\n\t * @param {string} key - The key to set.\n\t * @param {*} value - The value to store.\n\t * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.\n\t * @returns {Object|null} The evicted item (if any) with shape {key, value, expiry, prev, next}, or null.\n\t * @example\n\t * const cache = new LRU(2);\n\t * cache.set('a', 1).set('b', 2);\n\t * const evicted = cache.setWithEvicted('c', 3); // evicted = {key: 'a', value: 1, ...}\n\t * @see {@link LRU#set}\n\t * @see {@link LRU#evict}\n\t * @since 11.3.0\n\t */\n\tsetWithEvicted (key, value, resetTtl = this.resetTtl) {\n\t\tlet evicted = null;\n\n\t\tif (this.has(key)) {\n\t\t\tthis.set(key, value, true, resetTtl);\n\t\t} else {\n\t\t\tif (this.max > 0 && this.size === this.max) {\n\t\t\t\tevicted = {...this.first};\n\t\t\t\tthis.evict(true);\n\t\t\t}\n\n\t\t\tlet item = this.items[key] = {\n\t\t\t\texpiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,\n\t\t\t\tkey: key,\n\t\t\t\tprev: this.last,\n\t\t\t\tnext: null,\n\t\t\t\tvalue\n\t\t\t};\n\n\t\t\tif (++this.size === 1) {\n\t\t\t\tthis.first = item;\n\t\t\t} else {\n\t\t\t\tthis.last.next = item;\n\t\t\t}\n\n\t\t\tthis.last = item;\n\t\t}\n\n\t\treturn evicted;\n\t}\n\n\t/**\n\t * Sets a value in the cache. Updates the item's position to most recently used.\n\t *\n\t * @method set\n\t * @memberof LRU\n\t * @param {string} key - The key to set.\n\t * @param {*} value - The value to store.\n\t * @param {boolean} [bypass=false] - Internal parameter for setWithEvicted method.\n\t * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.set('key1', 'value1')\n\t *      .set('key2', 'value2')\n\t *      .set('key3', 'value3');\n\t * @see {@link LRU#get}\n\t * @see {@link LRU#setWithEvicted}\n\t * @since 1.0.0\n\t */\n\tset (key, value, bypass = false, resetTtl = this.resetTtl) {\n\t\tlet item = this.items[key];\n\n\t\tif (bypass || item !== undefined) {\n\t\t\t// Existing item: update value and position\n\t\t\titem.value = value;\n\n\t\t\tif (bypass === false && resetTtl) {\n\t\t\t\titem.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;\n\t\t\t}\n\n\t\t\t// Always move to end, but the bypass parameter affects TTL reset behavior\n\t\t\tthis.moveToEnd(item);\n\t\t} else {\n\t\t\t// New item: check for eviction and create\n\t\t\tif (this.max > 0 && this.size === this.max) {\n\t\t\t\tthis.evict(true);\n\t\t\t}\n\n\t\t\titem = this.items[key] = {\n\t\t\t\texpiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,\n\t\t\t\tkey: key,\n\t\t\t\tprev: this.last,\n\t\t\t\tnext: null,\n\t\t\t\tvalue\n\t\t\t};\n\n\t\t\tif (++this.size === 1) {\n\t\t\t\tthis.first = item;\n\t\t\t} else {\n\t\t\t\tthis.last.next = item;\n\t\t\t}\n\n\t\t\tthis.last = item;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an array of all values in the cache for the specified keys.\n\t * Order follows LRU order (least to most recently used).\n\t *\n\t * @method values\n\t * @memberof LRU\n\t * @param {string[]} [keys=this.keys()] - Array of keys to get values for. Defaults to all keys.\n\t * @returns {Array<*>} Array of values corresponding to the keys in LRU order.\n\t * @example\n\t * cache.set('a', 1).set('b', 2);\n\t * console.log(cache.values()); // [1, 2]\n\t * console.log(cache.values(['a'])); // [1]\n\t * @see {@link LRU#keys}\n\t * @see {@link LRU#entries}\n\t * @since 11.1.0\n\t */\n\tvalues (keys = this.keys()) {\n\t\tconst result = new Array(keys.length);\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tresult[i] = this.get(keys[i]);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\n/**\n * Factory function to create a new LRU cache instance with parameter validation.\n *\n * @function lru\n * @param {number} [max=1000] - Maximum number of items to store. Must be >= 0. Use 0 for unlimited size.\n * @param {number} [ttl=0] - Time to live in milliseconds. Must be >= 0. Use 0 for no expiration.\n * @param {boolean} [resetTtl=false] - Whether to reset TTL when accessing existing items via get().\n * @returns {LRU} A new LRU cache instance.\n * @throws {TypeError} When parameters are invalid (negative numbers or wrong types).\n * @example\n * // Create cache with factory function\n * const cache = lru(100, 5000, true);\n * cache.set('key', 'value');\n *\n * @example\n * // Error handling\n * try {\n *   const cache = lru(-1); // Invalid max\n * } catch (error) {\n *   console.error(error.message); // \"Invalid max value\"\n * }\n * @see {@link LRU}\n * @since 1.0.0\n */\nexport function lru (max = 1000, ttl = 0, resetTtl = false) {\n\tif (isNaN(max) || max < 0) {\n\t\tthrow new TypeError(\"Invalid max value\");\n\t}\n\n\tif (isNaN(ttl) || ttl < 0) {\n\t\tthrow new TypeError(\"Invalid ttl value\");\n\t}\n\n\tif (typeof resetTtl !== \"boolean\") {\n\t\tthrow new TypeError(\"Invalid resetTtl value\");\n\t}\n\n\treturn new LRU(max, ttl, resetTtl);\n}\n"],"names":["g","f","exports","module","define","amd","globalThis","self","lru","this","LRU","constructor","max","ttl","resetTtl","first","items","Object","create","last","size","clear","key","has","item","prev","next","entries","keys","result","Array","length","i","get","evict","bypass","expiresAt","expiry","undefined","Date","now","delete","moveToEnd","value","x","setWithEvicted","evicted","set","values","isNaN","TypeError"],"mappings":"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"}