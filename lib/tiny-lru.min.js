/**
 * Tiny LRU cache for Client or Server
 *
 * @author Jason Mulligan <jason.mulligan@avoidwork.com>
 * @copyright 2019
 * @license BSD-3-Clause
 * @version 6.0.0
 */(function(a){function b(a=1e3,b=0){return new c(a,b)}// Node, AMD & window supported
class c{constructor(a=0,b=0){this.first=null,this.items={},this.last=null,this.max=a,this.size=0,this.ttl=b}has(a){return a in this.items}clear(){return this.first=null,this.items={},this.last=null,this.size=0,this}delete(a){if(this.has(a)){const b=this.items[a];delete this.items[a],this.size--,null!==b.prev&&(b.prev.next=b.next),null!==b.next&&(b.next.prev=b.prev),this.first===b&&(this.first=b.next),this.last===b&&(this.last=b.prev)}return this}evict(){const a=this.first;return delete this.items[a.key],this.first=a.next,this.first.prev=null,this.size--,this}get(a){let b;if(this.has(a)){const c=this.items[a];0<this.ttl&&c.expiry<=new Date().getTime()?this.delete(a):(b=c.value,this.set(a,b,!0))}return b}keys(){return Object.keys(this.items)}set(a,b,c=!1){if(c||this.has(a)){const c=this.items[a];if(c.value=b,this.last!==c){const a=this.last,b=c.next,d=c.prev;this.first===c&&(this.first=c.next),c.next=null,c.prev=this.last,a.next=c,null!==d&&(d.next=b),null!==b&&(b.prev=d)}this.last=c}else{0<this.max&&this.size===this.max&&this.evict();const c=this.items[a]={expiry:0<this.ttl?new Date().getTime()+this.ttl:this.ttl,key:a,prev:this.last,next:null,value:b};1==++this.size?(this.first=c,this.last=c):(this.last.next=c,this.last=c)}return this}}"undefined"==typeof exports?"function"==typeof define&&void 0!==define.amd?define(()=>b):a.lru=b:module.exports=b})("undefined"==typeof window?global:window);
//# sourceMappingURL=tiny-lru.min.js.map